---
layout:       post                                          # 使用的布局（不需要改）
title:        关于反射的性能消耗                            # 标题 
subtitle:     关于反射的性能消耗                            # 副标题
date:         2018-03-07                                    # 时间
author:       xingxingxiaoyu                                # 作者
header-img:   "img/IMG_098.jpg"                             # 这篇文章标题背景图片
catalog:      true                                          # 是否归档
tags:                                                       # 标签
    - Java
---

一直听说Java的反射机制是很消耗性能的，可是与普通的方法相比到底有有多消耗呢？于是就写了个简单的例子尝试了下
以下是主程序：
<pre>
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
/** @author Administrator 反射的性能消耗测试
 */
public class ClassTest
{
    static final int N =  00000;
    public static void main(String[] args)
    {
        getTime();
        getTimeByClass();
    }
    public static void getTime()
    {
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < N; i++)
        {
            Person p = new Person("xuyu", i);
            String result = p.toString("aa");
        }
        long endTime = System.currentTimeMillis();
        System.out.println("不用反射的时间：" + (endTime - startTime));
    }
    public static void getTimeByClass()
    {
        try
        {
            Class<Person> aClass = Person.class;
            Constructor c = null;
            c = aClass.getConstructor(String.class, Integer.TYPE);
            Method m = aClass.getMethod("toString");
            S a = m.getAnnotation(S.class);
            long startTime = System.currentTimeMillis();
            for (int i = 0; i < N; i++)
            {
                Person p = (Person) c.newInstance("xuyu", i);
                String result = m.invoke(p) + a.value();
            }
            long endTime = System.currentTimeMillis();
            System.out.println("用反射的时间：" + (endTime - startTime));
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
</pre>
Person类：
<pre>
public class Person
{
    String name;
    int age;
    public String toString(String s)
    {
        return "Person [name=" + name + ", age=" + age + "]"+s;
    }
    @S(value = "aa")
    public String toString()
    {
        return "Person [name=" + name + ", age=" + age + "]";
    }
    public Person(String name, int age)
    {
        super();
        this.name = name;
        this.age = age;
    }
}
</pre>
注解：
<pre>
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface S
{
    String value();
}
</pre>
运行结果如下：
不用反射的时间：42
用反射的时间： 143
可以看出使用反射的时间大概是不使用的三倍多，并没有数量级上的差别，所以在项目中的一些不是主要耗时的功能是可以用反射写的。当然，反射毕竟消耗了更多的性能，如果不是非常需要，我们还是不要使用反射。
另外，如果把反射对象的获取也放在循环中：
<pre>
    public static void getTimeByClass()
    {
        try
        {
            long startTime = System.currentTimeMillis();
            for (int i = 0; i < N; i++)
            {
                Class<Person> aClass = Person.class;
                Constructor c = null;
                c = aClass.getConstructor(String.class, Integer.TYPE);
                Method m = aClass.getMethod("toString");
                S a = m.getAnnotation(S.class);
                Person p = (Person) c.newInstance("xuyu", i);
                String result = m.invoke(p) + a.value();
            }
            long endTime = System.currentTimeMillis();
            System.out.println("用反射的时间：" + (endTime - startTime));
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }
    </pre>
运行结果如下：
不用反射的时间：42
用反射的时间：456
可以看出对象的获取更加的消耗性能。所以在使用反射时，如果要获取很多的反射对象，也要主要其的性能消耗。
